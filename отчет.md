# ABC_IDZ_4
Вариант №18

# Отчет
## задание на 4, 5 и 6 баллов:
### Условие задачи:
18. Задача о болтунах. N болтунов имеют телефоны. Они либо ждут звон- ков, либо звонят друг другу, чтобы побеседовать. Если телефон случайного абонента занят, болтун будет звонить другому абоненту, пока ему кто-нибудь не ответит. Побеседовав некоторое время, болтун или ждет звонка, или зво- нит на другой случайный номер. Создать многопоточное приложение, мо- делирующее поведение болтунов. Для решения задачи использовать мью-тексы.

Модель параллельных вычислений - ???

Входные данные программы - количество болтунов, seed генерации псевдослучайных чисел и входн./выход. файлы.
Основной синхропримитив - мьютексы.
Результаты работы - вывод всех этапов параллельных вычислений, по которым можно сказать, что программа написана верно, так как все результаты этапов были выведены в правильном порядке + на одних и тех же входных данных имеем одинаковый вывод => состояние гонки не возникает.

В приведенном решении мьютексы - это разговор болтунов, если мьютекс закрыт => болтун говорит по телефону, открыт - этот болтун свободен и ему можно звонить. Потоки - это сами болтуны, которые решают, кому и когда звонить (исполняются по возможности одновременно, так как в условии задачи прослеживается одномоментная связь "многие ко многим". Синхронизируются потоки при помощи мьютексов. Идея синхронизции такая: каждый из N болтунов звонит другим N болтунам (для упрощения понимания полагаем, что у нас 2N болтунов). В цикле создаются N потоков, которые почти параллельно входят в нашу функцию call(). Первый поток звонит 1-ому абоненту, блокирует его мьютекс. Соответственно, 2-ой поток при входе в функцию call() не может позвонить 1-ому абоненту (конечно, если еще не истекло время разговора и "замок" не открылся). Итак, второй поток (болтун) звонит второму абоненту и так далее. Каж i-ый поток сначала смотерит на первые (i+1) мьютексов и звонит первому освободившемуся абоненту.

### _Опции компляции:_
Компиляция программы без оптимизирующих и отладочных опций (для оптимизации можно просто включить один из флагов -O1, -O2, -O3):
```sh
gcc main.c -g -pthread
```

Описание опций компиляции:
- -pthread - позволяет нам работать с потоками ОС
- -g - предоставляет отладочную информацию (в данном случае не нужен, но при отладке может помочь)


## задание на 6 баллов:

### С этого пункта и дальше см. файлы в папке diffrenent files (в папке 9_points).

Сделано максимальное использование регистров вместо ОЗУ для хранения лок. переменных (и аргументов, которые требуются для вычисления функции). Комментарии предоставлены в файле foo1.s & foo2.s в папке 9_points. Сишные файлы остались без изменений.
Размеры программ на языке ассембелра с модифицированной программой (дополнение регистров) примерно равны, их отличие - оптимизированная программа рабоатет быстрее (см. предыдущий пункт).
Однако оптимизированная програма (с помощью флагов оптимизации) занимает меньше строк в редакторе, нежели программа, скомпилированная стандратным путем, без опций оптимизации.

## задание на 7 баллов:
В командной строке принимаются 4 аргумента - 
- выбор способа введдения числа для извлечения корня: 1) введение числа вручную; 2) сгенерировать псевдослучайное число типа double; 3) взять число из файла для ввода данных (см. пункт ниже)
- полное имя файла для ввода (например, input.txt)
- полное имя файла для вывода (например, output.txt)
- если первый введенный аргумент был равен 1, то сейчас пользователь вводит число, корень которого хочет найти. Если 2, то seed генератора. Если 3, то любое значение (оно ни на что не влияет).
Файлы имеют стандартное расширение .txt, файл input.txt должен присутствовать.

## задание на 8 баллов:
Все необходимые модификации были сделаны в пунктах выше (включая прогоны, на одном из которых время выполнения превышает 1 сек благодаря зацикливанию вычислющего результат кода).

## задание на 9 баллов:
Указанные в задании тесты уже проводились (см. выше), производительность уже была отражена (количество секунд было выведено в консоль). Размер испольняемого файла - в случае оптимизированной программы это 8 кБ (8,041 байта), в случае неоптимизированной - 9 кБ (9,066 байт). Отличие в данном случае небольшое, но и программа невелика. Размер ассемблерного кода: в случае оптимизированной программы это 255 строчек в основном файле (foo1.s) и 111 строки в побочном файле (foo2.s), в случае программы без оптимизаций - 256 строчек в основном файле (foo1.s) и 125 строка в побочном файле (foo2.s). (в случае оптимизированной версии строчек боль из-за закомментированных строчек - чтобы было наглядко видно изменения в коде, было принято решение не удалять старые строчки, а комментировать их).
P.S. Оптимизации по скорости и размеру в данном случае практически равносильны. Так как программа небольшая, это утверждение корректно.
