# ABC_IDZ_4
Вариант №18

# Отчет
## задание на 4 и 5 баллов:
### _Опции компляции:_
Компиляция программы без оптимизирующих и отладочных опций:
```sh
gcc -S -masm=intel foo1.c
```
Компиляция программы с доп. опциями с целью убрать лишние макросы:
```sh
gcc -masm=intel -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions foo1.c -S -o foo1.s
```

Описание опций компиляции:
- -fno-asynchronous-unwind-tables - делает программу меньше по размеру, уменьшая EH-секцию
- -fno-jump-tables - предотвращает генерирование джамп-таблиц для конструкций switch
- -fno-stack-protector - отключение защиты стека от несанкционированного доступа (например, канарейка)
- -fno-exceptions - отключение обработки исключений у функций

Компиляция и компоновка ассемблерной программы без использования опций отладки:
```sh
as -o foo1.o foo1.s
gcc foo1.o
```
### _Опции компляции для многофайловой программы (она была написана сразу же):
Компиляция файлов foo1.c & foo2.c оптимизирующими и отладочными опциями:
```sh
gcc -masm=intel -O0 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions foo1.c -S -o foo1.s

gcc -masm=intel -O0 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions foo2.c -S -o foo2.s
```
Ассемблирование программ (с целью рефакторинга):
```sh
gcc foo1.s -c -o foo1.o
gcc foo2.s -c -o foo2.o
```
Компоновка и линковка в исполняемый файл:
```sh
gcc foo1.o foo2.o -o foo.out
```
Необходимые файлы предствлены в папке 9_points (две папки - комментарии добавлены к оптимизированной распределенной версии (она на 99% совпадает с неоптимизированной, см соотвествтвующие папки в папке 9_points).

### _Тестовые прогоны:_
Скриншот запуска тестов на обоих программах:
![Тесты(/tests/tests_1.png)

Замечание: в 60% случаев оптимизированная программа работает быстрее, в остальных же 40% оптимизированная программа чуть отстает от своей тривиальной версии, причина тому: код построен таким образом, что использование одной и той же переменной происходит в среднем всего 2, 3 раза, и поэтому мы дольше будем лазить в стек, чтобы положить в регистр число и работать с регистром, и наоборот, нежели просто будем работать со стеком.
## задание на 6 баллов:

### С этого пункта и дальше см. файлы в папке diffrenent files (в папке 9_points).

Сделано максимальное использование регистров вместо ОЗУ для хранения лок. переменных (и аргументов, которые требуются для вычисления функции). Комментарии предоставлены в файле foo1.s & foo2.s в папке 9_points. Сишные файлы остались без изменений.
Размеры программ на языке ассембелра с модифицированной программой (дополнение регистров) примерно равны, их отличие - оптимизированная программа рабоатет быстрее (см. предыдущий пункт).
Однако оптимизированная програма (с помощью флагов оптимизации) занимает меньше строк в редакторе, нежели программа, скомпилированная стандратным путем, без опций оптимизации.

## задание на 7 баллов:
В командной строке принимаются 4 аргумента - 
- выбор способа введдения числа для извлечения корня: 1) введение числа вручную; 2) сгенерировать псевдослучайное число типа double; 3) взять число из файла для ввода данных (см. пункт ниже)
- полное имя файла для ввода (например, input.txt)
- полное имя файла для вывода (например, output.txt)
- если первый введенный аргумент был равен 1, то сейчас пользователь вводит число, корень которого хочет найти. Если 2, то seed генератора. Если 3, то любое значение (оно ни на что не влияет).
Файлы имеют стандартное расширение .txt, файл input.txt должен присутствовать.

## задание на 8 баллов:
Все необходимые модификации были сделаны в пунктах выше (включая прогоны, на одном из которых время выполнения превышает 1 сек благодаря зацикливанию вычислющего результат кода).

## задание на 9 баллов:
Указанные в задании тесты уже проводились (см. выше), производительность уже была отражена (количество секунд было выведено в консоль). Размер испольняемого файла - в случае оптимизированной программы это 8 кБ (8,041 байта), в случае неоптимизированной - 9 кБ (9,066 байт). Отличие в данном случае небольшое, но и программа невелика. Размер ассемблерного кода: в случае оптимизированной программы это 255 строчек в основном файле (foo1.s) и 111 строки в побочном файле (foo2.s), в случае программы без оптимизаций - 256 строчек в основном файле (foo1.s) и 125 строка в побочном файле (foo2.s). (в случае оптимизированной версии строчек боль из-за закомментированных строчек - чтобы было наглядко видно изменения в коде, было принято решение не удалять старые строчки, а комментировать их).
P.S. Оптимизации по скорости и размеру в данном случае практически равносильны. Так как программа небольшая, это утверждение корректно.
